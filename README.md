# Сивкова Екатерина ИТ-16. Лабораторная работа №5. Вариант 2.

# Задание 1
Шаблоны.

## Задача 1
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
- Имеет числитель: целое число
- Имеет знаменатель: целое число
- Дробь может быть создана с указанием числителя и знаменателя
- Может вернуть строковое представление вида “числитель/знаменатель”
- Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
- Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

### Алгоритм решения
Создан интерфейс Fractions, в котором определены  методы для получения вещественного значения дроби, для установки числителя с автоматическим упрощением, для установки знаменателя с валидацией и упрощением.
Изменён ранее созданный класс Fraction. Добавлены приватные поля cachedDoubleValue - хранит вычесленное значение и isCache - флаг, посчитано значение ранее или нет. Для новых полей добавлены геттеры getCachedDoubleValue() и isCache() для получения данных. В конструкторах по умолчанию и с параметрами новым полям присваиваются значения null и false соответственно, а в конструкторе копирования значения этих полей копируются из переданного объекта. Класс Fraction реализует интерфейс Fractions, следовательно переопределены методы getDoubleFraction(), setNumerator() и setDenominator(). 

Метод getDoubleFraction() сначала проверяет было ли вычесленно вещественное значение дроби ранее, если нет (isCache == false или cachedDoubleValue == null), то происходит вычисление и устанавливается флаг true (значение вычеслено), иначе шаг с вычислением значения пропускается, возвращается вещественное значение дроби. 

Методы setNumerator() и setDenominator() - сеттеры для числителя и знаменателя. Каждый сохраняет новое значение числителя или знаменателя, далее обновляются значения полей cachedDoubleValue = null и isCache = false, так как для новой дроби вещественное значение ещё не вычислялось, и новая дробь упрощается.

Добавлены методы equals() и hashCode() для сравнения дробей. Метод equals() принимает на вход объект и возвращает одно из значений true (объекты равны) или false (объекты не равны). Если переданный объект является той же самой ссылкой, возвращает true. Если переданный объект null, возвращает false. Если переданный объект является экземпляром класса, приводит его к типу Fraction, в противном случает возвращает false. При прохождении всех проверок, сравниваются значения полей (дроби равны, когда у них одинаковые значения числителя и знаменателя). Метод hashCode() генерирует хэш-код объекта с помощью Objects.hash().

В основной программе продемонстрирована работа класса:
1. Создание дробей - объектов Fraction;
2. Вывод значений созданных дробей в упрощённом виде;
3. Вычисление вещественного значения дроби;
4. Создание двух равных дробей (если сократить);
5. Сравнение двух равных дробей, вывод их хэш-кодов;
6. Сравнение двух не равных дробей, вывод их хэш-кодов.

#### Тестирование
1.
- Дробь 1: 1/3
- Дробь 2: 1/2
- Дробь 3: -1/2
2.
- Первое вычисление вещественного значения дроби 1: 0.3333333333333333
- Второе вычисление вещественного значения дроби 1: 0.3333333333333333 (из кэша)
3.
- Сравнение: 1/2 и 1/2 = true
- Хэш-код 1/2 : 994
- Хэш-код 1/2 : 994
4.
- Сравнение: 1/3 и 1/2 = false
- Хэш-код 1/3 : 995
- Хэш-код 1/2 : 994

# Задание 2
Структурные шаблоны.

## Задача 1
### Текст задачи
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. Ниже показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.
25. Meowable m = ... //создаём кота
26. Funs.meowsCare(m);
27. System.out.println(...) //вывод: кот мяукал 5 раз

Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
  - Имеет Имя (строка)
  - Для создания необходимо указать имя кота.
  - Может быть приведен к текстовой форме вида: “кот: Имя”
  - Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
  - public void meow();

### Алгоритм решения

#### Тестирование

# Задание 3
Список.

## Задача 5
### Текст задачи
Составить программу, которая удаляет из списка L все элементы с указанным значением.

### Алгоритм решения
Создан класс ClassList с приватными полями list - исходный список чисел для обработки и result - результирующий список после применения операции удаления, списки хранят значения типа Number. Добавлены геттеры getList() и getResult() для получения данных и сеттер setList() для установки данных (с проверкой на null). Конструктор по умолчанию инициализирует пустые исходный и результирующий списки. Конструктор с параметрами принимает исходный список, проверяет его на значение null с помощью метода validateNull() из класса Validator, при успешной валидации, сохраняет исходный список в поле list и инициализирует пустой список для результатов. Метод toString() предоставляет строковое представление объекта ClassList, отображая исходные данные и результаты операции удаления.

Реализован метод remove() для удаления элемента с указанным значением из исходного списка. На вход принимается значение, которое необходимо удалить. Сначала проверяется возможность выполнения удаления, если список пустой, то удаление не возможно, метод завершает работу. Если исходный список содержит элементы, то метод последовательно обрабатывает каждый. Если текущий элемент не равен значению, которое нужно удалить (проверяется с помощью метода isEqual()), то элемент добавляется в результирующий список.

Приватный логический метод isEqual() используется для сравнения чисел. Сначала обрабатывается ситуация с null значениями, если оба числа null, возвращается true, если один null, возвращается false. Иначе, если оба числа не null, сравниваются числовые значения через приведение к вещественному типу с помощью метода doubleValue() из класса Number.

Класс Validator содержит следующие методы:
1. valIsInt(String value) - Определяет, может ли переданная строка быть корректно преобразована в целое число типа int.
2. valIsDouble(String value) - Определяет возможность преобразования строки в число с плавающей точкой типа double.
3. valIsNumber(String value) - Определяющая, представляет ли строка любое числовое значение - целое или дробное.
4. validateNullList(List<T> list) - Гарантирует корректность работы методов, принимающих коллекции, путем проверки на нулевые ссылки.

Используются следующие исключения:
1. IllegalArgumentException - передача null списка;
2. NumberFormatException - попытка преобразования строки в число при несоответствии формата - преобразуется в boolean;

В основной программе продемонстрирована работа класса:
1. Инициализируется пустой список и значение для удаления типа Number;
2. Вызывается приватный метод inputList() для заполнения пустого списка и ввода значения, которое нужно удалить (данные запрашиваются у пользователя и проверяются на корректность);
3. Создаётся экземпляр класса ClassList с ранее созданным списком;
4. Вызывается метод remove() для созданного экземпляра;
5. Результат выводится на экран.

#### Тестирование
1. Введите количество элементов в списке: 3w23
- Ошибка: введите корректное число.
2. Введите количество элементов в списке: 11
- Введите 1 элемент списка: 7
- Введите 2 элемент списка: -32.43
- Введите 3 элемент списка: jx31
  - Ошибка: введите корректное число.
- Введите 3 элемент списка: 4.40
- Введите 4 элемент списка: 91
- Введите 5 элемент списка: -7
- Введите 6 элемент списка: 7.0
- Введите 7 элемент списка: 21.5
- Введите 8 элемент списка: -0.3
- Введите 9 элемент списка: -267
- Введите 10 элемент списка: 7
- Введите 11 элемент списка: 42
3. Введите значение, которое хотите удалить: h3jh
- Ошибка: введите корректное число.
4. Введите значение, которое хотите удалить: 7
- Исходный список: [7, -32.43, 4.4, 91, -7, 7.0, 21.5, -0.3, -267, 7, 42]
- Результат удаления указанного элемента: [-32.43, 4.4, 91, -7, 21.5, -0.3, -267, 42]

# Задание 4
Мап. 

## Задача 2
### Текст задачи
На городской олимпиаде по информатике участникам было предложено выполнить 3 задания, каждое из которых оценивалось по 25-балльной шкале. Известно, что общее количество участников первого тура олимпиады не превосходит 250 человек. На вход программы подаются сведения о результатах олимпиады. В первой строке вводится количество участников N. Далее следуют N строк, имеющих следующий формат:
- <Фамилия><Имя><Баллы>

Здесь<Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не более чем из 15 символов;<Баллы>– строка, содержащая три целых числа, разделенных пробелом, соответствующих баллам, полученным участником за каждое задание первого тура. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Примеры входных строк:
- Петрова Ольга 25 18 16
- Калиниченко Иван 14 19 15

Напишите программу, которая будет выводить на экран фамилию и имя участника, набравшего максимальное количество баллов. Если среди остальных участников есть ученики, набравшие такое же количество баллов, то их фамилии и имена также следует вывести. При этом имена и фамилии можно выводить в произвольном порядке.

### Алгоритм решения
Создан класс ClassMap с приватными полями input - хранит исходные данные всех участников
result - хранит данные победителей (участников с максимальным баллом). Добавлены геттеры getInput() и getResult(), для получения данных и сеттер setInput() для установки данных (с проверкой на null). Конструктор по умолчанию инициализирует пустые исходный и результирующий контейнеры. Конструктор с параметром принимает файл, метод valFile() из класса Validator проверяет файл перед обработкой, далее происходит чтение данных из файла с помощью приватного метода readFile() и определение победителей с помощью метода selection(). Метод toString() проверяет контейнеры на пустоту, если пустые, выводит соответствующее сообщение и завершает работу. Иначе формирует и выводит списки всех участников и победителей.

Метод readFile():
1. Создается пустая HashMap для хранения результатов;
2. Создается BufferedReader для чтения файла построчно (FileReader открывает файл для чтения);
3. Чтение первой строки - получение количества участников (попытка преобразования строки в целое число, при ошибке - сообщение и возврат пустого Map, выход из метода);
4. Проверка, что количество участников ≤ 250 (при превышении - сообщение и возврат пустого Map, выход из метода);
5. Чтение n строк с данными участников (если файл закончился раньше - сообщение и прерывание цикла);
6. Каждая строка разбивается на Фамилию, Имя и 3 балла по пробелам (выполняется проверка что строка содержит ровно 5 частей, при несоответствии - сообщение и переход к следующей строке);
7. Проверка числового формата и диапазона баллов (0-25), преобразование строк в числа (используется valIsNumber() из класса Validator для проверки что баллы - числа, при ошибке - сообщение и переход к следующей строке);
8. Сохранение в формате: "Фамилия Имя балл1 балл2 балл3";
9. Возврат результата.

Метод selection():
1. Проход по всем участникам из input;
2. Вычисление суммарного балла для каждого участника;
3. Нахождение максимального суммарного балла;
4. Формирование списка всех участников с максимальным баллом.

Программа обрабатывает следующие исключения:
1. IllegalArgumentException - методы valFile() и validateNullMap() из класса Validator 
   - Некорректные входные данные (когда передается null вместо файла)
   - Файл не найден (метод exists() из класса File проверяет существет ли указанный файл в системе)
   - Файл пустой (метод length() из класса File возвращает размер файла и сравнивает с нулём)
   - Передан контейнер Map равный null 
2. RuntimeException - метод readFile()
   - Ошибка чтения файла (например, передан не файл, а директория)
3. NumberFormatException 
   - В методе readFile(): первая строка файла содержит некорректное значение количества участников
   - В методе Validator.valIsNumber(): баллы участников содержат нечисловые значения (возвращает false)

В основной программе продемонстрирована работа алгоритма:
1. Создание объекта с корректным файлом "ClassMapOneMax.txt" (содержит как корректные данные участников, среди которых один с максимальным баллом, так и строки с некорректными данными);
2. Создание объекта с файлом "ClassMapNotVal.txt" (содержит только строки с некорректными данными);
3. Создание объекта с корректным файлом "ClassMapManyMax.txt" (содержит корректные данные участников, среди которых несколько с максимальным баллом);
4. Создание объекта с файлом "ClassSet.txt" (первая строка не содержит количество участников);
5. Создание объекта с файлом "ClassMapFewStr.txt" (содержит меньше участников, чем указано в первой строке);
6. Создание объекта с файлом "ClassMapManyStr.txt" (первая строка содержит число - количество участников более 250);
7. Попытка создания объекта с файлом null;
8. Создание объекта с несуществующим файлом "Map.txt";
9. Создание объекта с пустым файлом "Empty.txt";
10. Создание объекта с указанием директории вместо файла.

#### Тестирование
1. Обработка файла с корректными и некорректными строками (один участник с максимальным баллом):
- Cтрока "Иванова Мария 9 -5 18" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Сидоров Юрий 61 1 15" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Романов Вельямин" пропущена, т.к. содержит некорректные данные.
- Cтрока "Анисимова Екатерина 10 2" пропущена, т.к. содержит некорректные данные.
- Cтрока "Сергеев Иван 8 20 3 16" пропущена, т.к. содержит некорректные данные.

- Список всех участников:
- Алексеев Пётр: 25 25 25;
- Петров Сергей: 23 5 12;
- Петров Иван: 2 15 6;
- Иванова Наташа: 12 25 16;
- Иванов Сергей: 3 8 10;
- Ветров Роман: 0 17 9;
- Бойцова Екатерина: 11 9 7;

- Список участников, набравших максимальное количество баллов:
- Алексеев Пётр: 25 25 25;

2. Обработка файла с только некорректными строками:
- Cтрока "Сидоров Юрий 221 1" пропущена, т.к. содержит некорректные данные.
- Cтрока "Романов Вельямин" пропущена, т.к. содержит некорректные данные.
- Cтрока "Алексеев Пётр 38 92 74" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Сергеев Иван -85 39" пропущена, т.к. содержит некорректные данные.
- В файле не найдено строк с корректными данными участников.

3. Обработка файла с только корректными строками (несколько участников с максимальным баллом):
- Список всех участников:
- Сергеев Иван: 8 20 3;
- Иванова Мария: 9 19 18;
- Анисимова Екатерина: 24 19 21;
- Петров Сергей: 23 21 20;
- Петров Иван: 17 25 22;
- Сидоров Юрий: 24 1 15;
- Иванова Наташа: 12 25 16;
- Иванов Сергей: 3 8 10;
- Ветров Роман: 0 17 9;
- Бойцова Екатерина: 11 9 7;

- Список участников, набравших максимальное количество баллов:
- Анисимова Екатерина: 24 19 21;
- Петров Сергей: 23 21 20;
- Петров Иван: 17 25 22;

4. Обработка некорректного файла (первая строка не содержит количество участников):
- Первая строка должна содержать количество участников.
6. Обработка некорректного файла (содержит меньше участников, чем указано в первой строке):
- Файл содержит меньше строк, чем указано.
8. Количество участников превышает 250.
9. Попытка создания объекта с файлом null:
- Ошибка: Файл не может быть null.
11. Попытка создания объекта с несуществующим файлом:
- Ошибка: Файл Map.txt не найден.
12. Попытка создания объекта с пустым файлом:
- Ошибка: Файл Empty.txt пустой.
13. Попытка создания объекта с указанием директории:
- Ошибка чтения файла D:\IdeaProjects.

# Задание 5
Сет.

## Задача 3
### Текст задачи
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все согласные буквы, которые входят ровно в одно слово.

### Алгоритм решения
Класс ClassSet содержит следующие private поля: text (String) - хранит исходный текст для анализа, letters (Set<Character>)  - хранит результирующее множество согласных букв, встречающихся ровно в одном слове. Добавлены методы доступа: getText(), getLetters(), setText(). Конструктор по умолчанию инициализирует text пустой строкой, создает пустое множество letters. Конструктор с параметром принимает файл, метод valFile() из класса Validator проверяет файл перед обработкой, далее происходит попытка чтения содержимого файла в поле text с помощью метода Files.readString() (при ошибке чтения, выбрасывает исключение с соответствующим сообщением), вызывается метод Text() для поиска согласных букв, входящих ровно в одно слово. Метод toString() проверяет множетство letters на пустоту, если множество пустое, возвращает соответсвующее сообщение, иначе выводит строковое представление множества letters.

Приватный метод Text() предназначен для поиска согласных букв, входящих ровно в одно слово. Создается множество русских согласных букв, текст приводится к нижнему регистру с помощью метода toLowerCase(), текст разбивается на слова по пробелам с помощью метода split(). Далее обрабатывается каждое слово (находим уникальные символы в каждом слове): создается временное множество для хранения уникальных согласных текущего слова, каждый символ слова проверяется на принадлежность к множеству согласных, найденные согласные добавляются во временное множество. Затем для каждой уникальной согласной из текущего слова увеличивается счетчик в HashMap (если согласная встречается впервые, для нее создается запись со значением 1, если согласная уже встречалась в других словах, ее счетчик увеличивается на 1). Для формирования результата: проходим по всем записям HashMap с подсчитанными частотами, отбираем только те согласные, которые встречаются ровно один раз (значение счетчика = 1), добавляем отфильтрованные согласные в TreeSet для автоматической сортировки в алфавитном порядке.

Программа обрабатывает следующие исключения:
1. IllegalArgumentException - метод valFile из класса Validator
   - Некорректные входные данные (когда передается null вместо файла)
   -  Файл не найден (метод exists() из класса File проверяет существет ли указанный файл в системе)
   -  Файл пустой (метод length() из класса File возвращает размер файла и сравнивает с нулём)
2. RuntimeException - конструктор с параметрами
   - Ошибка чтения файла (например, передан не файл, а директория)

В основной программе продемонстрирована работа алгоритма:
1. Создание объекта с корректным файлом "ClassSet.txt" (содержит текст: "Тестирование работы программы");
2. Попытка создания объекта с файлом null;
3. Создание объекта с несуществующим файлом "Set.txt";
4. Создание объекта с пустым файлом "Empty.txt";
5. Создание объекта с указанием директории вместо файла.

#### Тестирование
- Согласные входящие ровно в одно слово: [б, в, г, м, н, п, с]
- Ошибка: Файл не может быть null.
- Ошибка: Файл Set.txt не найден.
- Ошибка: Файл Empty.txt пустой.
- Ошибка чтения файла D:\IdeaProjects.

# Задание 6
Очередь. 

## Задача 4
### Текст задачи
Проверить равенство участка очереди с i-го по j-й элемент (i < j).

### Алгоритм решения
Создан класс ClassQueue с приватными полями queue - исходная очередь чисел для обработки (хранит значения типа Number) и result - результат проверки равенства участка очереди. Добавлены геттеры getQueue() и getResult() для получения данных и сеттер setQueue() для установки данных (с проверкой на null). Конструктор по умолчанию инициализирует пустую исходную очередь. Конструктор с параметрами принимает исходную очередь, проверяет её на значение null с помощью метода validateNull() из класса Validator, при успешной валидации, сохраняет исходную очередь в поле queue. Метод toString() предоставляет строковое представление объекта ClassQueue, отображая исходные данные и результат операции проверки.

Реализован метод equality() для проверки равенства участка очереди с  i-го по j-й элемент (i < j). На вход принимаются целые значения индексов. Сначала проверяются входные параметры, если индексы i и j отрицательные, i < j или j превышает размер очереди, то выбрасываются исключения с соответствующими сообщениями, метод завершает работу. Если входные параметры корректны, то создаётся итератор для прохода по элементам очереди. С помощью цикла for метод проходит через первые i элементов, на каждой итерации вызов iterator.next() перемещает итератор к следующему элементу. После цикла итератор устанавливается на первый элемент участка (элемент с индексом i). Заранее предполагается, что элементы участка от i до j равны. Далее итератор проходит по элементам от i + 1 до j и каждый сравнивает с первым. Если нашёлся текущий элемент не равный первому элементу участка, (проверяется с помощью метода equal()), то устанавливаем result = false и завершаем работу цикла, не проверяя оставшиеся элементы (даже если не достигли индекса j).

Класс Validator содержит следующие методы:
1. valIsInt(String value) - Определяет, может ли переданная строка быть корректно преобразована в целое число типа int.
2. valIsDouble(String value) - Определяет возможность преобразования строки в число с плавающей точкой типа double.
3. valIsNumber(String value) - Определяющая, представляет ли строка любое числовое значение - целое или дробное.
4. validateNullQueue(Queue<T> queue) - Гарантирует корректность работы методов, принимающих коллекции, путем проверки на нулевые ссылки.

Используются следующие исключения:
1. IllegalArgumentException - передача null очереди;
2. NumberFormatException - попытка преобразования строки в число при несоответствии формата - преобразуется в boolean;

В основной программе продемонстрирована работа класса:
1. Инициализируется пустая очередь;
2. Вызывается приватный метод inputQueue() для заполнения пустой очереди (данные запрашиваются у пользователя и проверяются на корректность);
3. Создаётся экземпляр класса ClassQueue с ранее созданной очередью;
4. Запрашивается ввод индексов i и j (реализован приватный метод inputIndex() с проверкой корректности введённых значений); 
5. Вызывается метод equality() для созданного экземпляра; 
6. Результат выводится на экран.

#### Тестирование
1.
- Введите количество элементов в очереди: ру3
- Ошибка: введите корректное число.
- Введите количество элементов в очереди: 7
- Введите 1 элемент очереди: 1
- Введите 2 элемент очереди: 2
- Введите 3 элемент очереди: 2
- Введите 4 элемент очереди: 2
- Введите 5 элемент очереди: 3
- Введите 6 элемент очереди: 4
- Введите 7 элемент очереди: 2
- Введите начальный индекс i: 2
- Введите конечный индекс j: 4
- Очередь: [1, 2, 2, 2, 3, 4, 2]
- Результат проверки: true
2.
- Введите количество элементов в очереди: 5
- Введите 1 элемент очереди: 4
- Введите 2 элемент очереди: ео42
- Ошибка: введите корректное число.
- Введите 2 элемент очереди: 5
- Введите 3 элемент очереди: 5
- Введите 4 элемент очереди: 3
- Введите 5 элемент очереди: 1
- Введите начальный индекс i: 2
- Введите конечный индекс j: 4
- Очередь: [4, 5, 5, 3, 1]
- Результат проверки: false
3.
- Введите количество элементов в очереди: 7
- Введите 1 элемент очереди: 9
- Введите 2 элемент очереди: 3
- Введите 3 элемент очереди: 4
- Введите 4 элемент очереди: 4
- Введите 5 элемент очереди: 4
- Введите 6 элемент очереди: 3
- Введите 7 элемент очереди: 4
- Введите начальный индекс i: 3к4
- Ошибка: введите корректный индекс.
- 2
- Введите конечный индекс j: 4
- Очередь: [9, 3, 4, 4, 4, 3, 4]
- Результат проверки: false

# Задание 7
Стрим.

## Задача 1
### Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
  - Координата Х: число.
  - Координата Y: число.
  - Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
  - Координата начала: Точка
  - Координата конца: Точка
  - Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
  - Имеет массив Точек, через которые линия проходит.
  - Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это результат приведения к строке Точки с номером N.

### Алгоритм решения

#### Тестирование

## Задача 2
### Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
- Вася:5
- Петя:3
- Аня:5

Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее: читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру:
- [5:[Вася, Аня], 3:[Петя]]

### Алгоритм решения

#### Тестирование
