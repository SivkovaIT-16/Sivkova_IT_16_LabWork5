# Сивкова Екатерина ИТ-16. Лабораторная работа №5. Вариант 2.

# Задание 1
Шаблоны.

## Задача 1
### Текст задачи
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя.
Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения.
Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями:
- Имеет числитель: целое число
- Имеет знаменатель: целое число
- Дробь может быть создана с указанием числителя и знаменателя
- Может вернуть строковое представление вида “числитель/знаменатель”
- Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным.
- Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби
считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

### Алгоритм решения
Создан интерфейс Fractions, в котором определены метод для получения вещественного значения дроби и метод для установки числителя и знаменателя.

Изменён ранее созданный класс Fraction. Переопределены методы getDoubleFraction() для нахождения вещественного значения числа и setFraction() - для изменения дроби (с проверкой нового значения знаменателя и автоматическим упрощением дроби). Добавлены методы equals() и hashCode() для сравнения дробей. Метод equals() принимает на вход объект и возвращает одно из значений true (объекты равны) или false (объекты не равны). Если переданный объект является той же самой ссылкой, возвращает true. Если переданный объект null, возвращает false. Если переданный объект является экземпляром класса, приводит его к типу Fraction, в противном случает возвращает false. При прохождении всех проверок, сравниваются значения полей (дроби равны, когда у них одинаковые значения числителя и знаменателя). Метод hashCode() генерирует хэш-код объекта с помощью Objects.hash().

Реализован класс FractionCache - шаблон для кэширования вещественного значения дроби. Переопределены методы интерфейса Fractions с добавлением логики кэширования. При первом вызове getDoubleFraction() значение вычисляется и сохраняется в кэш. При последующих вызовах значение возвращается из кэша без пересчета. При изменении дроби через setFraction() кэш сбрасывается.

В основной программе продемонстрирована работа класса:
1. Создание дроби - объекта Fraction;
2. Вывод значений созданной дроби в упрощённом виде;
3. Создание объекта FractionCache для кэширования вычислений;
4. Первый вызов getDoubleFraction() - вычисление и сохранение в кэш;
5. Повторный вызов getDoubleFraction() - использование значения из кэша;
6. Изменение значения дроби через объект класса FractionCache с автоматическим сбросом кэша;
7. Вывод обновленной дроби и пересчитанного вещественного значения кэша;
8. Создание двух равных дробей (если сократить);
9. Сравнение двух равных дробей, вывод их хэш-кодов;
10. Сравнение двух не равных дробей, вывод их хэш-кодов.

#### Тестирование
1. Дробь 1: -1/2
2. Вычисление и кэширование вещественного значения дроби 1: -0.5
- Повторный вызов нахождения вещественного значения (не считаем заново, берём из кэша): - -0.5
3. Изменяем значение дроби 1.
- Дробь 1: 77/2
- Вещественное значение в кэше пересчитано: 38.5
4. Сравнение: 3/5 и 3/5 = true
- Хэш-код 3/5 : 1059
- Хэш-код 3/5 : 1059
5. Сравнение: 77/2 и 3/5 = false
- Хэш-код 77/2 : 3350
- Хэш-код 3/5 : 1059

# Задание 2
Структурные шаблоны.

## Задача 1
### Текст задачи
Количество мяуканий.
Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4.
Необходимо таким образом передать кота в указанный метод, чтобы после окончания его работы узнать сколько раз мяукал кот за время его работы. Ниже показан пример работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.
25. Meowable m = ... //создаём кота
26. Funs.meowsCare(m);
27. System.out.println(...) //вывод: кот мяукал 5 раз

Если раннее в вашем варианте не было Кота, то создайте
1. сущность Кот, которая описывается следующим образом:
  - Имеет Имя (строка)
  - Для создания необходимо указать имя кота.
  - Может быть приведен к текстовой форме вида: “кот: Имя”
  - Может помяукать, что приводит к выводу на экран следующего текста: “Имя: мяу!”, вызвать мяуканье можно без параметров.
2. интерфейс Мяуканье: разработайте метод, который принимает набор объектов способных мяукать и вызывает мяуканье у каждого объекта. Мяукающие объекты должны иметь метод со следующей сигнатурой:
  - public void meow();

### Алгоритм решения
Создан интерфейс Meow, определяющий метод meow() - метод для издания звука "мяу" - для всех мяукающих объектов.

Создан класс Cat, который реализует интерфейс Meow и представляет сущность "Кот" и реализует метод мяуканья. Поле класса: name типа final String (неизменяемое поле) хранит имя кота. Геттер getName()  предоставляет доступ к имени кота. Конструктор принимает имя кота, проверяет его на null, если проверка не пройдена - выбрасывает исключение, иначе переданное имя записывается в поле класса. Переопределён метод meow(), который выводит строку в виде "Имя кота: мяу!". Переопределён метод toString(), который представляет информацию об объекте в ввиде строки "Кот: имя кота".

Создан класс CountMeowCat является декоратором (структурный шаблон), который реализует интерфейс Meow и добавляет функциональность подсчета мяуканий к существующему объекту Cat. Поля класса: cat - ссылка на объект класса Cat (неизменяемое поле), meowCount типа int - счетчик количества мяуканий. Геттеры: getCat() - предоставляет доступ к оригинальному коту, getMeowCount() - предоставляет текущее количество мяуканий. Конструктор принимает объект класса Сat, проверяет что переданный кот не null, если проверка пройдена сохраняет в поле ссылку на кота и инициализирует счётчик нулём. Переопределён метод meow(), который делегирует вызов мяуканья оригинальному методу meow() из класса Cat и увеличивает счётчик на еденицу. Переопределён метод toString(), который используя метод toString() из класса Cat предоставляет информацию об объекте в виде строки "Кот: 'имя' помяукал ... раз".

Класс Funs реализует статический метод meowsCare() для одновременного мяуканья нескольких котов. Метод принимает переменное число любых объектов, которые реализуют интерфейс Meow. Аргументы автоматически преобразовываются в массив, и с помощью цикла перебора для каждого вызывается мяуканье.

В программе обрабатывается исключение IllegalArgumentException - для проверки передаваемых значений на null.

В основной программе продемонстрирована работа класса:
1. Создание кота. Программа просит пользователя ввести имя кота и проверяет его на коррректность (если имя пустое, выводит соответствующее сообщение и просит повторить ввод);
2. Выбор действия для пользователя:
   - Вызов мяуканья у созданного кота
   - Подсчёт количества мяуканий созданного кота
   - Завершение программы

#### Тестирование
1. Создайте кота.
- Введите имя кота: 
- Ошибка: введите корректное имя кота
- Введите имя кота: Барсик
- Кот: Барсик создан.
2. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 1
- Барсик: мяу!
3. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 1
- Барсик: мяу!
4. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 2
- Кот: Барсик помяукал 2 раз.
5. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 1
- Барсик: мяу!
6. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 2
- Кот: Барсик помяукал 3 раз.
7. Выберете действие:
- 0.Завершить программу.
- 1.Вызвать мяуканье.
- 2.Сколько раз кот мяукал?
- 0
- Программа "Кот мяукает" завершена.

# Задание 3
Список.

## Задача 5
### Текст задачи
Составить программу, которая удаляет из списка L все элементы с указанным значением.

### Алгоритм решения
В классе Methods реализован статический метод removeAll() для удаления элемента с указанным значением из исходного списка. На вход принимается список элементов и значение, которое необходимо удалить. C помощью метода validateNullList() из класса Validator исходный список проверяется на значение null. Если список пуст, возвращается пустой список (т.к. удалять нечего) и метод завершает работу. Если исходный список содержит элементы, то метод создаёт новый пустой список result. Метод последовательнообрабатывает каждый элемент исходного списка. Если текущий элемент и значения для удаления - числа, то они преобразовываются в double и сравниваются. Иначе используется сравнение двух объектов с помощью статического метода Objects.equals(). Если текущий элемент и переданное значения для удаления не равны, то текущий элемент добавляется в список result. Возвращается список result.

Класс Validator содержит следующие методы:
1. valIsInt(String value) - Определяет, может ли переданная строка быть корректно преобразована в целое число типа int.
2. valIsDouble(String value) - Определяет возможность преобразования строки в число с плавающей точкой типа double.
3. valIsNumber(String value) - Определяющая, представляет ли строка любое числовое значение - целое или дробное.
4. validateNullList(List<T> list) - Гарантирует, что переданный список не является null.

Используются следующие исключения:
1. IllegalArgumentException - передача null списка;
2. NumberFormatException - попытка преобразования строки в число при несоответствии формата - преобразуется в boolean;

В основной программе продемонстрирована работа класса:
1. Отображение меню, пользователь выбирает тип элементов списка;
2. Инициализируется пустой список и значение для удаления;
3. В зависимости от выбранного типа элементов вызывается один из приватных методов inputListNumber() или inputListString() для заполнения пустого списка и ввода значения, которое нужно удалить (данные запрашиваются у пользователя и проверяются на корректность);
4. Вызов метода removeAll() обрабатывает список;
5. Исходный список и результат выводятся на экран.

#### Тестирование
1. Выберете действие:
- 0.Завершить программу.
- 1.Работа со списком чисел.
- 2.Работа со списком строк.
- 1
- Введите количество элементов в списке: 3о2
- Ошибка: введите корректное число.
- Введите количество элементов в списке: 11
- Введите 1 элемент списка: 3
- Введите 2 элемент списка: -49
- Введите 3 элемент списка: 3.00
- Введите 4 элемент списка: 1
- Введите 5 элемент списка: zj2
- Ошибка: введите корректное число.
- Введите 5 элемент списка: -9.32
- Введите 6 элемент списка: -3
- Введите 7 элемент списка: 3
- Введите 8 элемент списка: 28
- Введите 9 элемент списка: 3.0
- Введите 10 элемент списка: -3.0
- Введите 11 элемент списка: 39
- Введите значение, которое хотите удалить: 3
- Исходный список: [3, -49, 3.0, 1, -9.32, -3, 3, 28, 3.0, -3.0, 39]
- Удаляем элемент: 3.0
- Результат удаления: [-49, 1, -9.32, -3, 28, -3.0, 39]

2. Выберете действие:
- 0.Завершить программу.
- 1.Работа со списком чисел.
- 2.Работа со списком строк.
- 2
- Введите количество строк в списке: 7
- Введите 1 строку списка: js
- Введите 2 строку списка: 3o34
- Введите 3 строку списка: js    
- Введите 4 строку списка: djs
- Введите 5 строку списка: js
- Введите 6 строку списка: poi3
- Введите 7 строку списка:    js
- Введите строку, которую хотите удалить: js
- Исходный список: [js, 3o34, js    , djs, js, poi3,    js]
- Удаляем элемент: js
- Результат удаления: [3o34, js    , djs, poi3,    js]

3. Выберете действие:
- 0.Завершить программу.
- 1.Работа со списком чисел.
- 2.Работа со списком строк.
- 0

# Задание 4
Мап. 

## Задача 2
### Текст задачи
На городской олимпиаде по информатике участникам было предложено выполнить 3 задания, каждое из которых оценивалось по 25-балльной шкале. Известно, что общее количество участников первого тура олимпиады не превосходит 250 человек. На вход программы подаются сведения о результатах олимпиады. В первой строке вводится количество участников N. Далее следуют N строк, имеющих следующий формат:
- <Фамилия><Имя><Баллы>

Здесь<Фамилия>– строка, состоящая не более чем из 20 символов;<Имя>– строка, состоящая не более чем из 15 символов;<Баллы>– строка, содержащая три целых числа, разделенных пробелом, соответствующих баллам, полученным участником за каждое задание первого тура. При этом <Фамилия> и <Имя>, <Имя> и <Баллы> разделены одним пробелом. Примеры входных строк:
- Петрова Ольга 25 18 16
- Калиниченко Иван 14 19 15

Напишите программу, которая будет выводить на экран фамилию и имя участника, набравшего максимальное количество баллов. Если среди остальных участников есть ученики, набравшие такое же количество баллов, то их фамилии и имена также следует вывести. При этом имена и фамилии можно выводить в произвольном порядке.

### Алгоритм решения
В классе Methods реализован статический метод findParticipants() для нахождения участников с максимальным суммарным баллом. На вход принимается файл и проверяется на корректность с помощью метода valFile() из класса Validator (если проверка не пройдена, выбрасывается исключение и метод завершает обработку входного файла). Инициализируется контейнер TreeMap, который хранит пары "Сумма баллов - имя" в отсортированом по возрастанию порядке. Для чтения файла создается объект BufferedReader, который использует FileReader для доступа к файлу и обеспечивает буферизированное чтение текста. Далее метод читает первую строку файла, для получения количества участников n (проверяется, что n является целым числом и n <= 250, при ошибке - вывод сообщения и завершение метода). С помощью цикла происходит построчное чтение данных участников. Для чтения очередной строки используется метод readLine(). Каждая строка проверяется на значение null, при отсутствии строки выводится сообщение об ошибке и метод завершает работу. Текущая строка разбивается на 5 частей с помощью метода split(), проверяется, что она состоит ровно из 5 элементов, при ошибке - строка пропускается с выводом соответствующего сообщения. Происходит проверка, что последние три части строки - целые числа (используется метод valIsInt() из класса Validator), каждое из которых в диапазоне [0, 25], при  ошибке - строка пропускается с выводом соответствующего сообщения. Вычисляется общая сумма баллов, а также в строковую переменную записывается имя участника (1 + 2 части текущей строки). Данные участника записываются в контейнер. Если контейнер не содержит участников с таким же суммарным баллом, то для данного ключа сначала создаётся пустой список. После завершения чтения файла, контейнер проверяется на пустоту, если пустой - вывод сообщения ""Нет участников с корректными данными.", иначе извлекается последняя запись контейнера, которая содержит ключ - максимальный балл, значение - список победителей. Список выводится на экран.

Программа обрабатывает следующие исключения:
1. IllegalArgumentException - методы valFile() из класса Validator 
   - Некорректные входные данные (когда передается null вместо файла)
   - Файл не найден (метод exists() из класса File проверяет существет ли указанный файл в системе)
   - Файл пустой (метод length() из класса File возвращает размер файла и сравнивает с нулём)
2. RuntimeException - метод findParticipants()
   - Ошибка чтения файла (например, передан не файл, а директория)
3. NumberFormatException 
   - В методе findParticipants(): первая строка файла содержит некорректное значение количества участников
   - В методе valIsInt(): баллы участников содержат не целочисленные значения (возвращает false)

В основной программе продемонстрирована работа алгоритма на примере различных файлов.

#### Тестирование
1. Обработка файла с корректными и некорректными строками (один участник с максимальным баллом):
- Cтрока "Иванова Мария 9 -5 18" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Сидоров Юрий 61 1 15" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Романов Вельямин" пропущена, т.к. содержит некорректные данные.
- Cтрока "Анисимова Екатерина 10 2" пропущена, т.к. содержит некорректные данные.
- Cтрока "Сергеев Иван 8 20 3 16" пропущена, т.к. содержит некорректные данные.

- Участники с максимальным баллом (75):
- Алексеев Пётр

2. Обработка файла с только некорректными строками:
- Cтрока "Сидоров Юрий 221 1" пропущена, т.к. содержит некорректные данные.
- Cтрока "Романов Вельямин" пропущена, т.к. содержит некорректные данные.
- Cтрока "Алексеев Пётр 38 92 74" пропущена, т.к. содержит некорректные значения баллов.
- Cтрока "Сергеев Иван -85 39" пропущена, т.к. содержит некорректные данные.
- Cтрока "Бойцова Екатерина 11 9 7.43" пропущена, т.к. содержит некорректные значения баллов.
- Нет участников с корректными данными.

3. Обработка файла с только корректными строками (несколько участников с максимальным баллом):
- Участники с максимальным баллом (64):
- Анисимова Екатерина
- Петров Сергей
- Петров Иван

4. Обработка некорректного файла (первая строка не содержит количество участников):
- Первая строка должна содержать количество участников.

5. Обработка некорректного файла (содержит меньше участников, чем указано в первой строке):
- Файл содержит меньше строк, чем указано.

6. Обработка некорректного файла (первая строка содержит количество участников более 250):
- Количество участников превышает 250.
  
7. Попытка создания объекта с файлом null:
- Ошибка: Файл не может быть null.

8. Попытка создания объекта с несуществующим файлом:
- Ошибка: Файл Map.txt не найден.

9. Попытка создания объекта с пустым файлом:
- Ошибка: Файл Empty.txt пустой.
  
10. Попытка создания объекта с указанием директории:
- Ошибка чтения файла D:\IdeaProjects.

# Задание 5
Сет.

## Задача 3
### Текст задачи
Файл содержит текст на русском языке. Напечатать в алфавитном порядке все согласные буквы, которые входят ровно в одно слово.

### Алгоритм решения
В классе Methods реализован статический метод findUniqueLetters(), который предназначен для поиска согласных букв, входящих ровно в одно слово. На вход принимается файл и проверяется на корректность с помощью метода valFile() из класса Validator (если проверка не пройдена, выбрасывается исключение и метод завершает обработку входного файла). Используется метод readString() класса Files, который считывает содержимое файла в ранее инициализированную строку text. Инициализируется множество TreeSet() result для согласных, которые встретились ровно в одном слове (автоматическая сортировка по алфавиту). Создается множество русских согласных букв, текст приводится к нижнему регистру с помощью метода toLowerCase(), текст разбивается на слова по пробелам с помощью метода split(). Инициализируется множество HashSet() lettersNotUnique для согласных, которые встретились более одного раза. Далее обрабатывается каждое слово (находим уникальные символы в каждом слове): создается временное множество HashSet() lettersWord для хранения уникальных согласных текущего слова, слово преобразуется в массив символов (метод toCharArray()), каждый символ слова проверяется на принадлежность к множеству согласных, найденные согласные добавляются во временное множество. Затем, для каждой уникальной согласной из текущего слова с помощью метода contains() проверяется, содержится ли она во множестве с пповторяющимися буквами lettersNotUnique, если да - переходим к следующей, иначе проверяем содержание этой согласной во множестве уникальных символов. Если согласная уже содержится во множестве уникальных символов result, значит она содержится не в одном слове, переносим её во множество lettersNotUnique, иначе (если согласной нет не в одном множестве), добавляем её во множество уникальных символов result. После обработки каждого слова, проверяем множество result на пустоту и выводим резуьтат.

Программа обрабатывает следующие исключения:
1. IllegalArgumentException - метод valFile из класса Validator
   - Некорректные входные данные (когда передается null вместо файла)
   -  Файл не найден (метод exists() из класса File проверяет существет ли указанный файл в системе)
   -  Файл пустой (метод length() из класса File возвращает размер файла и сравнивает с нулём)
2. RuntimeException - метод findUniqueLetters()
   - Ошибка чтения файла (например, передан не файл, а директория)

В основной программе продемонстрирована работа алгоритма на примере различных файлов.

#### Тестирование
1. Обработка корректного файла:
- Согласные входящие ровно в одно слово: [б, в, г, м, н, п, с]
2. Обработка файла, содержащего только гласные:
- Нет согласных, входящих ровно в одно слово.
3. Попытка создания объекта с файлом null:
- Ошибка: Файл не может быть null.
4. Попытка создания объекта с несуществующим файлом:
- Ошибка: Файл Set.txt не найден.
5. Попытка создания объекта с пустым файлом:
- Ошибка: Файл Empty.txt пустой.
6. Попытка создания объекта с указанием директории:
- Ошибка чтения файла D:\IdeaProjects.

# Задание 6
Очередь. 

## Задача 4
### Текст задачи
Проверить равенство участка очереди с i-го по j-й элемент (i < j).

### Алгоритм решения
В классе Methods реализован статический метод equality() для проверки равенства участка очереди с  i-го по j-й элемент (i < j). На вход принимаются очередь (проверяется на значение null с помощью метода validateNullQueue из класса Validator) и целые значения индексов (если индексы i и j отрицательные, i < j или j превышает размер очереди, то выбрасываются исключения с соответствующими сообщениями, метод завершает работу). Если входные параметры корректны, то создаётся итератор для прохода по элементам очереди. С помощью цикла for метод проходит через первые i элементов, на каждой итерации вызов iterator.next() перемещает итератор к следующему элементу. После цикла итератор устанавливается на первый элемент участка (элемент с индексом i). Задаём логической перемнной result значение true, заранее предполагая, что элементы участка от i до j равны. Далее итератор проходит по элементам от i + 1 до j и каждый сравнивает с первым. Если нашёлся текущий элемент не равный первому элементу участка, (проверяется с помощью метода equal()), то устанавливаем result = false и завершаем работу цикла, не проверяя оставшиеся элементы (даже если не достигли индекса j). Выводим исходную очередь и результат проверки в консоль.

Класс Validator содержит следующие методы:
1. valIsInt(String value) - Определяет, может ли переданная строка быть корректно преобразована в целое число типа int.
2. valIsDouble(String value) - Определяет возможность преобразования строки в число с плавающей точкой типа double.
3. valIsNumber(String value) - Определяющая, представляет ли строка любое числовое значение - целое или дробное.
4. validateNullQueue(Queue<T> queue) - Гарантирует, что переданная очередь не является null.

Используются следующие исключения:
1. IllegalArgumentException - передача null очереди;
2. NumberFormatException - попытка преобразования строки в число при несоответствии формата - преобразуется в boolean;

В основной программе продемонстрирована работа класса:
1. Отображение меню, пользователь выбирает тип элементов очереди;
2. Инициализируется пустая очередь;
3. В зависимости от выбранного типа элементов вызывается один из приватных методов inputQueueNumber() или inputQueueString() для заполнения пустой очереди(данные запрашиваются у пользователя и проверяются на корректность);
4. Запрашивается ввод индексов i и j (реализован приватный метод inputIndex() с проверкой корректности введённых значений);
5. Вызов метода equality() проверяет равенство с i по j элемент очереди;
6. Исходная очередь и результат выводятся на экран.

#### Тестирование
1.Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 1
- Введите количество элементов в очереди: ру3
- Ошибка: введите корректное число.
- Введите количество элементов в очереди: 7
- Введите 1 элемент очереди: 1
- Введите 2 элемент очереди: 2
- Введите 3 элемент очереди: 2
- Введите 4 элемент очереди: 2
- Введите 5 элемент очереди: 3
- Введите 6 элемент очереди: 4
- Введите 7 элемент очереди: 2
- Введите начальный индекс i: 2
- Введите конечный индекс j: 4
- Очередь: [1, 2, 2, 2, 3, 4, 2]
- Результат проверки: true
3. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 1
- Введите количество элементов в очереди: 7
- Введите 1 элемент очереди: 9
- Введите 2 элемент очереди: ео42
- Ошибка: введите корректное число.
- Введите 2 элемент очереди: 3
- Введите 3 элемент очереди: 4
- Введите 4 элемент очереди: 4
- Введите 5 элемент очереди: 4
- Введите 6 элемент очереди: 3
- Введите 7 элемент очереди: 4
- Введите начальный индекс i: 3к4
- Ошибка: введите корректный индекс.
- 2
- Введите конечный индекс j: 4
- Очередь: [9, 3, 4, 4, 4, 3, 4]
- Результат проверки: false
4. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 2
- Введите количество элементов в очереди: оа4
- Ошибка: введите корректное число.
- Введите количество элементов в очереди: 8
- Введите 1 элемент очереди: abc
- Введите 2 элемент очереди: xy
- Введите 3 элемент очереди: hello
- Введите 4 элемент очереди: hello
- Введите 5 элемент очереди: hello
- Введите 6 элемент очереди: hello
- Введите 7 элемент очереди: hello)
- Введите 8 элемент очереди: ab
- Введите начальный индекс i: 3
- Введите конечный индекс j: 7
- Очередь: [abc, xy, hello, hello, hello, hello, hello), ab]
- Результат проверки: false
5. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 2
- Введите количество элементов в очереди: 7
- Введите 1 элемент очереди: s
- Введите 2 элемент очереди: s
- Введите 3 элемент очереди: s
- Введите 4 элемент очереди: 
- Ошибка: введена пустая строка. Повторите попытку.
- Введите 4 элемент очереди: s
- Введите 5 элемент очереди: kx
- Введите 6 элемент очереди: n3i
- Введите 7 элемент очереди: 0
- Введите начальный индекс i: k3n
- Ошибка: введите корректный индекс.
- 1
- Введите конечный индекс j: 4
- Очередь: [s, s, s, s, kx, n3i, 0]
- Результат проверки: true
6. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 1
- Введите количество элементов в очереди: 3
- Введите 1 элемент очереди: 1
- Введите 2 элемент очереди: 2
- Введите 3 элемент очереди: 3
- Введите начальный индекс i: 0
- Введите конечный индекс j: 2
- Ошибка: Некорректные индексы: i должно быть меньше j и оба > 0
7. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 2
- Введите количество элементов в очереди: 4
- Введите 1 элемент очереди: j
- Введите 2 элемент очереди: r
- Введите 3 элемент очереди: 65
- Введите 4 элемент очереди: s
- Введите начальный индекс i: 2
- Введите конечный индекс j: 5
- Ошибка: Индекс j превышает размер очереди
8. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 2
- Введите количество элементов в очереди: 3
- Введите 1 элемент очереди: f
- Введите 2 элемент очереди: f
- Введите 3 элемент очереди: e
- Введите начальный индекс i: 3
- Введите конечный индекс j: 2
- Ошибка: Некорректные индексы: i должно быть меньше j и оба > 0
9. Выберете действие:
- 0.Завершить программу.
- 1.Работа с очередью чисел.
- 2.Работа с очередью строк.
- 0

# Задание 7
Стрим.

## Задача 1
### Текст задачи
Необходимо написать стрим:
Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline)
Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их:
1. класс Point:
  - Координата Х: число.
  - Координата Y: число.
  - Может возвращать текстовое представление вида “{X;Y}”.
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
  - Координата начала: Точка
  - Координата конца: Точка
  - Может возвращать текстовое представление вида “Линия от {X1;Y1} до {X2;Y2}”
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
  - Имеет массив Точек, через которые линия проходит.
  - Может быть приведена к строковой форме вида “Линия [Т1,T2,…,TN]”, где TN – это результат приведения к строке Точки с номером N.

### Алгоритм решения
Создан класс Point c полями x и y типа double, который представляет точку на плоскости с координатами (x, y). Добавлены геттеры для получения данных и сеттеры для установки данных. Конструктор принимает два параметра типа double, инициализирует поля и возвращает новый объект Point. Метод toString() возвращает информацию о точке в виде строки "{x;y}". Метод equals() принимает объект и возвращает true (объекты одинаковые) или false (объекты разные). Если объект является тем же самым в памяти, возвращает true. Если переданный объект null, возвращает false. Если объект не является экземпляром класса Point, возвращает false, иначе преобразует Object в Point и сравнивает поля. Метод hashCode() генерирует хэш-код.

Создан класс Line с полями start - начальная точка отрезка и end - конечная точка отрезка типа Point представляет отрезок на плоскости, ограниченный двумя точками.  Добавлены геттеры для получения данных и сеттеры для установки данных c проверкой на null. Конструктор принимает два параметра типа Point, проверяет что они не null (если одна из точек null, выбрасывает исключение с соответствующим сообщением), инициализирует поля и возвращает новый объект Line. Метод toString() возвращает информацию об отрезке в виде строки "Линия от {x1;y1} до {x2;y2}".

Создан класс Line с полем points - список точек ломаной линии типа List<Point> представляет ломаную линию, состоящую из последовательности точек. Добавлены геттер для получения данных и сеттер для установки данных c проверкой на null. Конструктор по умолчанию создает пустой список точек new ArrayList<>() и инициализирует поле points. Конструктор с параметром принимает спосок точек, проверяет что список не null  с помощью метода validateNullList() из класса Validator (если список null, выбрасывает исключение с соответствующим сообщением), присваевает переданный список полю класса и возвращает новый объект Polyline. Метод addPoint() для добавления точки в список принимает точку, проверяет, что она не null, и добавляет её в список (если переданная точка null, метод ничего не делает). Метод toString() возвращает информацию о линии в виде строки "Линия [{x1;y1}, {x2;y2}, ..., {xn;yn}]".

Создан класс PointStream с полями points - исходный список точек (тип List<Point>) и resultPolyline - результирующая ломаная линия (тип Polyline), который обрабатывает коллекцию точек и строит ломаную линию с помощью потока данных stream. Добавлены геттеры для получения данных и сеттер для установки данных с проверкой переданного списка на null (с помощью метода validateNullList() класса Validator) и вызовом метода collectPolyline() для построения новой ломанной. Конструктор с параметром принимает список точек, проверяет его на на null (с помощью метода validateNullList() класса Validator), сохраняет список точек и вызывает метод collectPolyline() для построения ломанной линии. Метод toString() возвращает строковое представление информации о классе: возвращается исходный список точек в виде "Точки: [{x1;y1}, {x2;y2}, ..., {xn;yn}]" и построенная ломанная линия в виде "Ломанная: Линия [{x1;y1}, {x2;y2}, ..., {xn;yn}]". Если исходный список пустой метод возвращает строку "Список точек пустой. Невозможно создать линию." и завершает работу.

Метод collectPolyline() служит для построения ломанной линии. Реализован следующий алгоритм:
1. Создание пототока points.stream().
2. Сортировка по X. Используется метод .sorted(). Создаётся компаратор для сравнения точек по X, который получает координату X (используется геттер getX() класса Point) и сортирует точки в порядке возрастания X.
3. Преобразование Y. Используется метод .map(). Для каждой точки применяется метод mapY.
4. Удаление дубликатов. Используется метод .distinct(), который удаляет одинаковые точки, используя методы equals() и hashCode() класса Point.
5. Сбор в список. Используется метод .collect(), который преобразует поток обратно в список.
6. Создание ломаной. Возвращается объект Polyline из обработанных точек.

Вспомогательный метод mapY() находит новую координату newY, вычисляя модуль от старого занчения (получает с помощью геттера getY() класса Point) и возвращает новую точку с исходным x и новым newY.

Класс Validator содержит следующие методы:
1. valIsInt(String value) - Определяет, может ли переданная строка быть корректно преобразована в целое число типа int.
2. valIsDouble(String value) - Определяет возможность преобразования строки в число с плавающей точкой типа double.
3. validateNullList(List<T> list) - Гарантирует корректность работы методов, принимающих список, путем проверки на нулевые ссылки.

Используются следующие исключения:
1. IllegalArgumentException - передача null списка;
2. NumberFormatException - попытка преобразования строки в число при несоответствии формата - преобразуется в boolean;

Приватный метод inputPoint() в классе Main запрашивает у пользователя количество точек (проверяет введённое значение на корректность с помощью метода valIsInt()), если вводится число 0, метод возвращает пустой список и завершает работу. Если количество точек положительное, метод запрашивает ввод координат X и Y (проверяет введённые значения на корректность с помощью метода valDouble()). Если какая-либо проверка не пройдена, выводится соответствующее сообщение, ввод повторяется. Если все проверки успешно пройдены, создаётся объект Point с введенными координатами, точка добавляется в список (выводится сообщение о успешном добавлении). Возвращается заполненный список точек

В основной программе продемонстрирована работа класса:
1. Ввод списка точек с помощью приватного метода inputPoint();
2. Создание потока - объекта класса PointStream;
3. Вывод результата.

#### Тестирование
Тест 1:
1. Введите количество точек: 0
- Точки: []
- Ломанная: Список точек пустой. Невозможно создать линию.

Тест 2:
1. Введите количество точек: 3jwe4
- Ошибка: введите целое неотрицательное число.
- Введите количество точек: 11
2. Ввод координат 1 точки.
- Введите координату X: 1
- Введите координату Y: 1
- Точка {1.0;1.0} добавлена.
3. Ввод координат 2 точки.
- Введите координату X: 5.4
- Введите координату Y: -2
- Точка {5.4;-2.0} добавлена.
4. Ввод координат 3 точки.
- Введите координату X: 1.0
- Введите координату Y: 1
- Точка {1.0;1.0} добавлена.
5. Ввод координат 4 точки.
- Введите координату X: -6.9
- Введите координату Y: -0.23
- Точка {-6.9;-0.23} добавлена.
6. Ввод координат 5 точки.
- Введите координату X: 4
- Введите координату Y: 9.08
- Точка {4.0;9.08} добавлена.
7. Ввод координат 6 точки.
- Введите координату X: 3.76
- Введите координату Y: -11
- Точка {3.76;-11.0} добавлена.
8. Ввод координат 7 точки.
- Введите координату X: 1.0
- Введите координату Y: -1.0
- Точка {1.0;-1.0} добавлена.
9. Ввод координат 8 точки.
- Введите координату X: 8.56
- Введите координату Y: 9
- Точка {8.56;9.0} добавлена.
10. Ввод координат 9 точки.
- Введите координату X: -13
- Введите координату Y: 0
- Точка {-13.0;0.0} добавлена.
11. Ввод координат 10 точки.
- Введите координату X: 4jd
- Ошибка: введите корректное значение координаты X.
- Введите координату X: 1.04
- Введите координату Y: kd2
- Ошибка: введите корректное значение координаты Y.
- Введите координату Y: 1
- Точка {1.04;1.0} добавлена.
12. Ввод координат 11 точки.
- Введите координату X: 0
- Введите координату Y: -4.1
- Точка {0.0;-4.1} добавлена.
13. Точки: [{1.0;1.0}, {5.4;-2.0}, {1.0;1.0}, {-6.9;-0.23}, {4.0;9.08}, {3.76;-11.0}, {1.0;-1.0}, {8.56;9.0}, {-13.0;0.0}, {1.04;1.0}, {0.0;-4.1}]
14. Ломанная: Линия [{-13.0;0.0}, {-6.9;0.23}, {0.0;4.1}, {1.0;1.0}, {1.04;1.0}, {3.76;11.0}, {4.0;9.08}, {5.4;2.0}, {8.56;9.0}]

## Задача 2
### Текст задачи
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме:
- Вася:5
- Петя:3
- Аня:5

Номера людей могут повторяться. У каких-то людей может не быть номера.
Необходимо написать стрим выполняющую следующее: читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру:
- [5:[Вася, Аня], 3:[Петя]]

### Алгоритм решения
Создан класс HumanStream с полями file - файл с исходными данными (тип File) и humansStream - сгруппированные данные (тип Map<Integer, List<String>>), который предназначен для чтения и обработки данных о людях из текстового файлаи их группировки по числовым значениям. Геттеры getFile() и getHumansStream() предоставляют контролируемый доступ к приватным полям класса. Сеттер setFile(File file) проверяет переданныф файл, при успешной проверке обновляет поля класса. Конструктор принимает файл в виде параметра, валидирует его, при успешной валидации сохраняет файл в поле file, а для поля humansStream вызывает метод collectionHuman(), который обрабатывает данные. Метод toString() возвращает строку "Нет корректных данных для отображения.", если результирующая коллекция оказалась пустая. Если же данные не пустые, создаёт строку - заголовок, проходит по всем элементам результирующего контейнера, записывая результаты в строку, и возвращает сгруппированные данные.

Приватный метод collectionHuman(File file) используется для обработки данных из файла и их группировки по числовым значениям:
1. Чтение всех строк файла в поток (Stream);
2. Фильтрация корректных строк. Отбираются только строки, содержащие символ двоеточия с помощью метода .filter(), который использует лямбда - выражение (проверка, что строка содержит двоеточие);
3. Преобразование строк в объекты контейнера Map c с помощью метода .map(), который использует вспомогательный метод mapName();
4. Удаление некорректных записей с помощью метода .filter(), который использует лямбда - выражение (проверка, что запись не null);
5. Группировка данных по ключам с преобразованием значений. Используется метод .collect(), который использует Collectors.groupingBy() - метод преобразования в коллекцию, принимающий следующие параметры:
  - Map.Entry::getKey - получение ключа из пары и группировка элементов по ключу;
  - Collectors.mapping() - преобразование значений в имена в каждой группе, принимает параметры Map.Entry::getValue для извлечения имени из каждой пары и Collectors.toList() для сбора извлечённых значений в список;

Приватный метод mapName() принимает строку из файла в качестве параметра, разделяет её по символу ':', проверяет формат (должно быть ровно две части), приводит имя к корректному виду ( первая буква - заглавная, остальные - строчные) с помощью метода substring(), который возвращает нужную часть строки. Далее переходит к валидации числа, используя метод valIsInt() из класса Validator. При успешном прохождении проверок, вторая часть преобразовывается из строки в число и создаётся пара "число - имя". Если строка некорректна возвращается null.

Программа обрабатывает следующие исключения:
1. IllegalArgumentException - метод valFile из класса Validator
   - Некорректные входные данные (когда передается null вместо файла)
   -  Файл не найден (метод exists() из класса File проверяет существет ли указанный файл в системе)
   -  Файл пустой (метод length() из класса File возвращает размер файла и сравнивает с нулём)
2. RuntimeException - конструктор с параметрами
   - Ошибка чтения файла (например, передан не файл, а директория)
3.  NumberFormatException - метод valIsInt из класса Validator 
  - Ошибка при попытке преобразования строки в число при несоответствии формата - преобразуется в boolean;

В основной программе продемонстрирована работа класса:
1. Создание объекта с корректным файлом "HumanStream.txt" (содержит корректные и некорректные строки);
2. Создание объекта с корректным файлом "HumanStreamNotVal.txt" (содержит только некорректные строки);
3. Попытка создания объекта с файлом null;
4. Создание объекта с несуществующим файлом "Human.txt";
5. Создание объекта с пустым файлом "Empty.txt";
6. Создание объекта с указанием директории вместо файла.

#### Тестирование
1. Обработка файла с корректными и некорректными строками:
- Сгруппированные данные:
- 2: [Маша];
- 3: [ петя, Оля];
- 5: [Вася, Аня];
- 7: [Вера , Коля];
2. Обработка файла с только некорректными строками:
- Нет корректных данных для отображения.
3. Попытка создания объекта с файлом null:
- Ошибка: Файл не может быть null.
4. Попытка создания объекта с несуществующим файлом:
- Ошибка: Файл Human.txt не найден.
5. Попытка создания объекта с пустым файлом:
- Ошибка: Файл Empty.txt пустой.
6. Попытка создания объекта с указанием директории:
- Ошибка чтения файла: D:\IdeaProjects
